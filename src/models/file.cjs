// @ts-check
const store = require("../../").notStore;
const config = require("not-config").readerForModule("store");

const MODEL_NAME = "File";

const FIELDS = [
    //unique identifier in DB
    "uuid",
    //original name, or changed by user
    ["name", {}, "filename"],
    //file type
    "extension",
    //store name
    "store",
    //object collection of data generated by processors
    "info", //complex object with all additional information about file
    //unique identifier in FS.
    //could be path /some/path/to/file.ext,
    //or it could be Key of object in Cloud
    "path",
    //size of file in bytes
    "size",
    //owner
    ["userIp", {}, "ip"],
    ["userId", 'not-node//userId'],
    ["session", { required: !!config.get("sessionRequired") }],
    //dates
    "createdAt",
    "updatedAt",
];

exports.thisModelName = MODEL_NAME;

exports.enrich = {
    versioning: true,
    increment: true,
    incrementOptions: {
        filter: ["store"], //fileID field counters unique for each Store
    },
    validators: true,
};

exports.FIELDS = FIELDS;

exports.schemaOptions = {
    timestamps: true,
};

exports.thisStatics = {
    async getOneByIdAndRemove(_id, sessionId) {
        try {
            let query = {
                _id,
                __latest: true,
                __closed: false,
            };
            if (sessionId) {
                query["session"] = sessionId;
            }
            let rec = await this.findOne(query);
            if (!rec) {
                return false;
            }
            const storage = await store.get(rec.store);
            if (!storage) {
                return false;
            }
            //removing file
            const plainObj = rec.toObject();
            const [, info] = await storage.delete(plainObj.path, plainObj.info);
            //updating document as closed
            await rec.close({ info });
            return rec;
        } catch (e) {
            return false;
        }
    },
};

exports.thisMethods = {};
